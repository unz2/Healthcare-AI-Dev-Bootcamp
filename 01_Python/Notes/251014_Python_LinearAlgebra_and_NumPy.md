# Python 선형대수 기초 및 넘파이

## 🎯 목표
1. 스칼라(Scalar), 벡터(Vector), 행렬(Matrix)
2. NumPy(넘파이)란?
3. Python List 와 NumPy Array
4. 전치 행렬
5. 행렬의 덧셈과 뺄셈
6. 내적과 행렬 곱
7. 가중치(Weigh)와 가중합(Weighted Sum)

---
## 1. 스칼라(Scalar), 벡터(Vector), 행렬(Matrix)

|구분|정의|특징|예시|
|---|---|---|---|
|스칼라|크기만 있고 방향이 없는 물리량 |0차원 텐서 (단일 숫자)|$a = 5$|
|벡터| 크기와 방향을 동시에 가지는 물리량|1차원 텐서 (숫자의 나열)|$\mathbf{v} = [1, 2, 3]$|
|행렬| 숫자들이 직사각형 형태로 배열된 것|2차원 텐서 (행과 열 존재)|$A = \begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix}$|


## 2. NumPy(넘파이)란?
- 파이썬에서 산술 계산을 위해 필수적으로 사용되는 핵심 라이브러리
- **다차원 배열 객체**: ndarray라는 효율적인 다차원 배열 구조를 제공한다.
- **고성능 연산**: 내부적으로 C와 Fortran으로 작성되어 파이썬 기본 리스트보다 훨씬 빠른 연산 속도를 자랑한다.
- **수학 함수 라이브러리**: 선형대수, 통계, 푸리에 변환 등 복잡한 수학적 연산을 위한 방대한 함수를 포함하고 있다.
- **데이터 생태계의 기초**: Pandas, Matplotlib, Scikit-learn 등 대부분의 데이터 분석 도구가 NumPy를 기반으로 구축되어 있다.

```Python
# NumPy 패키지 불러오기
import numpy as np

# 1. 스칼라 (0D Array)
scalar = np.array(5)

# 2. 벡터 (1D Array)
vector = np.array([1, 2, 3])

# 3. 행렬 (2D Array)
matrix = np.array([
    [1, 2, 3],
    [4, 5, 6]
])
```

## 3. Python List 와 NumPy Array

### Python List
- 파이썬의 기농 내장 기능
- 숫자, 문자, 다른 리스트까지 여러 데이터 타입을 섞어 쓸 수 있다.
- 각 원소의 주소를 저장하는 방식으로 메모리를 많이 차지한다.
- 산술 연산을 지원하지 않음 (리스트 전체에 산술 연산을 사용하려면 반복문 사용해야함)
- 모든 데이터의 종류를 일일이 확인해야 하므로 대규모 계산 시 속도가 저하된다.

### NumPy Array
- 연속된 메모리 공간에 데이터를 저장하여 리스트보다 메모리 효율성이 더 좋다.
- 단일 데이터 타입만 허용된다.
- 벡터화 연산을 지원하여 반복문 없이 배열 전체를 한 번에 계산할 수 있다.


## 4. 전치 행렬
- 행과 열을 서로 바꾼 행렬
- $A$의 전치는 $A^T$로 표기한다.
```Python
A = np.array([
    [1, 2, 3],
    [4, 5, 6]
])

A_transpose = A.T
# [[1, 4], 
#  [2, 5],
#  [3, 6]]
```

## 5. 행렬의 덧셈과 뺄셈
- 두 행렬의 크기(Shape)가 같아야 하며, 같은 위치의 원소끼리 계산한다.
```Python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

add_result = A + B  # [[6, 8], [10, 12]]
sub_result = A - B  # [[-4, -4], [-4, -4]]

```

## 6. 내적과 행렬 곱
### **내적(Dot Product)**
- 두 벡터의 대응하는 성분끼리 곱한 뒤 모두 더한 값
- 단순 요소별 곱셈이 아닌 가중합을 계산하여 특성이 결과에 얼마나 기여하는지 종합하는 과정이다.
- 공식: $\mathbf{a} \cdot \mathbf{b} = \sum a_i b_i$
```Python
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

dot_product = np.dot(a, b) # 1*4 + 2*5 + 3*6 = 32
```

### **행렬 곱**
- 앞 행렬의 열 개수와 뒤 행렬의 행 개수가 일치해야 연산이 가능하다.
- 결과 행렬의 $(i, j)$ 성분은 앞 행렬의 $i$번째 행과 뒤 행렬의 $j$번째 열의 내적이다.
- 연산자: `np.dot(A, B)` 또는 `@` 연산자를 사용한다.
```Python
A = np.array([[1, 2], 
              [3, 4]]) # (2x2)

B = np.array([[5, 6], 
              [7, 8]]) # (2x2)

# 행렬 곱 계산
# [ (1*5 + 2*7), (1*6 + 2*8) ]
# [ (3*5 + 4*7), (3*6 + 4*8) ]
C = A @ B        # [[19, 22], [43, 50]]
D = np.dot(A, B) # [[19, 22], [43, 50]]
```

## 7. 가중치(Weigh)와 가중합(Weighted Sum)
**가중치**: 입력 데이터의 각 성분이 결과에 미치는 중요도를 나타내는 수치  
**가중합**: 각 입력 값에 해당 가중치를 곱한 후 모두 더한 값

### 가중합 계산 원리
입력 벡터 $\mathbf{x} = [x_1, x_2, \dots, x_n]$  
가중치 벡터 $\mathbf{w} = [w_1, w_2, \dots, w_n]$  
가중합 $y = w_1x_1 + w_2x_2 + \dots + w_nx_n + b$  
($b$는 편향(Bias)으로, 결과값에 더해지는 상수)

```Python
# NumPy로 가중합 계산하기
# 입력 데이터와 가중치 설정
inputs = np.array([0.5, 0.8, -0.2])
weights = np.array([0.4, 0.7, 0.1])
bias = 0.1

# 가중합 계산 (내적 활용)
weighted_sum = np.dot(inputs, weights) + bias
print(weighted_sum) # (0.5*0.4 + 0.8*0.7 + -0.2*0.1) + 0.1 = 0.84
```