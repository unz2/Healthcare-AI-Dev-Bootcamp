# FastAPI Asynchronous

> 🗓️ **2026-01-15**  
> ✍🏼 **작성자 : unz**

---

## 📝 목차

1. 동기(Synchronous)란?
2. 비동기(Asynchronous)란?
3. Python Asyncio
4. 비동기 프로그래밍 시 주의점

---

## 1. 동기(Synchronous)란?

> 작업이 순차적으로 실행되는 방식

- 한 작업이 시작되면 그 작업이 끝날 떄까지 다음 작업은 대기 상태가 된다.

```python
import time

def hello():
    time.sleep(2) # 2초 대기
    print("Hello")

hello() # 2초 후 Hello 출력
```

### 1-1. 동기의 문제점

- DB에서 데이터를 가져오거나 외부 API를 호출하는 등 시간이 걸리는 작업이 발생하면 프로그램은 그 결과가 올 때까지 아무것도 하지 못하고 기다린다.
  - CPU는 충분히 다른 일을 할 수 있음에도 불구하고, 응답을 기다리느라 멈춰 있게 된다.
  - 웹 서버의 경우 한 명의 요청을 처리하는 동안 다른 사용자의 요청을 처리하지 못해 서버 전체가 느려질 수 있다.

```
I/O 작업
- CPU와 메모리가 외부 장치와 데이터를 주고받는 모든 과정
- 컴퓨터 내부에서 일어나는 계산 업무 외에 사용자, 인터넷, 디스크 등과  소통하는 모든 행위

Input(입력): 외부 데이터를 컴퓨터 안(메모리)으로 가져오는 것
Output(출력): 내부의 데이터를 외부로 내보내는 것
```

## 2. 비동기(Asynchronous)란?

> 작업의 완료를 기다리지 않고 다음 작업을 즉시 수행하는 방식

- 특정 작업이 완료되면 그때 결과를 받아 처리한다.

### 2-1. 비동기가 필요한 상황

- I/0 대기 시간이 긴 상황
- 대규모 사용자 요청 처리 (Web Server)
- 여러 개의 외부 API 동시 호출
- 파일 읽기/쓰기 및 데이터베이스 쿼리

## 3. Python Asyncio

> 파이썬에서 비동기 프로그래밍을 구현하기 위한 표준 라이브러리

- 이벤트 루프를 통해 여러 작업을 관리한다.

### 3-1. 코루틴(Coroutine)

> 실행 도중에 잠시 멈췄다가 나중에 다시 시작할 수 있는 함수

- 혼자 독점하지 않고, 서로 양보하면서 실행되는 함수
- asyncio의 핵심 : 코루틴들을 번갈아 실행시키는 것
- `async def` 키워드로 코루틴을 정의한다.

```python
import asyncio

async def hello():
    print("Hello")

coro1 = hello()
coro2 = hello()

async def main():
    await asyncio.gather(coro1, coro2)

asyncio.run(main())
```

```
코루틴은 언제 양보할까?

코루틴은 I/O를 기다리며 대기 시간이 발생할 때 양뵤한다.
→ 하지만 언제 대기시간이 발생할 지 코루틴이 알아서 판단할 수는 없음

따라서 개발자가 특정한 키워드를 통해 "여기서 기다려야 한다"는 지점을 표시해준다.
→ 그러면 asyncio는 그 지점에서 코루틴의 실행을 멈추고, 다른 코루틴을 실행한다.
```

### 3-2. await

> 비동기 작업의 결과를 기다릴 때 사용하는 키워드

- `await` 뒤에 오는 작업이 끝날 때까지 코루틴의 실행을 잠시 멈추고 제어권을 넘긴다.

```python
async def a():
    print("A: 시작")          # 1️⃣ a() 실행 시작
    await asyncio.sleep(2)   # 2️⃣ 여기서 양보 (2초 대기)
    print("A: 끝")           # 5️⃣ 다시 깨어나서 실행

async def b():
    print("B: 시작")          # 3️⃣ b() 실행 시작
    await asyncio.sleep(1)   # 4️⃣ 여기서 양보 (1초 대기)
    print("B: 끝")           # 6️⃣ 먼저 깨어나서 실행
```

```
⭐️ await를 쓰는 두 가지 필수 조건
1. 비동기 함수(코루틴) 안에서만 사용 가능
→ async def로 정의된 함수 내부가 아니면 await를 쓸 수 없다.

2. 대상 작업이 awaitable일 때
→ 기다려야 하는 대상이 기다릴 수 있는 객체여야 한다.

⭐️ awaitable인지 판단하는 방법
1. async def로 정의된 함수인가?
→ 호출하면 코루틴 객체를 반환하므로 await 가능

2. 비동기 라이브러리에서 온 함수인가? (예: asyncio, aiohttp, asyncpg, aiofiles 등)
→ 대부분 awaitable

3. I/O 대기 시간이 발생하는 작업인가?
→ 비동기 버전으로 사용 시 awaitable일 가능성 높음
```

### 3-3. 이벤트 루프(Event Loop)

> 누가 언제 실행 될지를 판단하고 순서를 조정하는 역할

- 이벤트 루프틑 코루틴들을 관찰하다가, `await`로 인해 대기 상태가 된 작업 대신 실행 가능한 다른 작업을 찾아 실행시킨다.

### 3-4. asyncio 핵심 요약

1. `async def` 로 코루틴을 만든다.
2. `await` 로 비동기 작업을 기다리며 제어권을 넘긴다.
3. `asyncio.gather()` 등을 통해 여러 코루틴을 동시에 실행한다.

## 4. 비동기 프로그래밍 시 주의점

> "절대로 이벤트 루프를 블로킹하면 안된다"

- 이벤트 루프는 여러 코루틴의 실행 순서를 관리하고 대기 중인 작업을 실행하는 관리자
- 따라서 이벤트 루프가 멈추면 모든 비동기 작업이 함께 멈춘다.
- 비동기 함수 안에서 `time.sleep()`이나 동기 방식의 `requests` 라이브러리를 사용하면, 이벤트 루프 자체가 멈춰버려 다른 모든 비동기 작업이 중단된다.

```
블로킹(Blocking)
- 오래 걸리는 작업이 실행 흐름을 붙잡고 다른 작업에게 제어권을 넘기지 않는 것
- await 없이 오래 걸리는 작업을 계속 실행하면 이벤트 루프가 다른 코루틴을 실행하지 못함
```

```python
import time

# 나쁜 예 (이벤트 루프가 멈춤)
async def bad_task():
    time.sleep(5) # 전체 서버가 5초간 마비

# 좋은 예 (다른 작업이 동시에 돌아감)
async def good_task():
    await asyncio.sleep(5) # 5초간 대기하는 동안 다른 코루틴 실행 가능
```
